//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./src/main/java/com/google/gson/stream/JsonReader.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JsonReader.h"
#include "JsonReaderInternalAccess.h"
#include "JsonScope.h"
#include "JsonToken.h"
#include "JsonTreeReader.h"
#include "MalformedJsonException.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"

@interface GsonJsonReader () {
 @public
  /*!
   @brief The input JSON.
   */
  JavaIoReader *in_;
  /*!
   @brief True to accept non-spec compliant JSON
   */
  jboolean lenient_;
  /*!
   @brief Use a manual buffer to easily read and unread upcoming characters, and
  also so we can create strings without an intermediate StringBuilder.
   We decode literals directly out of this buffer, so it must be at least as
  long as the longest token that can be reported as a number.
   */
  IOSCharArray *buffer_;
  jint pos_;
  jint limit_;
  jint lineNumber_;
  jint lineStart_;
  /*!
   @brief A peeked value that was composed entirely of digits with an optional
  leading dash.Positive values may not have a leading 0.
   */
  jlong peekedLong_;
  /*!
   @brief The number of characters in a peeked number literal.Increment 'pos' by
  this after reading a number.
   */
  jint peekedNumberLength_;
  /*!
   @brief A peeked string that should be parsed on the next double, long or string.
   This is populated before a numeric value is parsed and used if that parsing
  fails.
   */
  NSString *peekedString_;
  IOSIntArray *stack_;
  jint stackSize_;
  IOSObjectArray *pathNames_;
  IOSIntArray *pathIndices_;
}

- (jint)peekKeyword;

- (jint)peekNumber;

- (jboolean)isLiteralWithChar:(jchar)c;

/*!
 @brief Returns the string up to but not including <code>quote</code>, unescaping any
  character escape sequences encountered along the way.The opening quote
  should have already been read.
 This consumes the closing quote, but does
  not include it in the returned string.
 @param quote either ' or ".
 @throw NumberFormatExceptionif any unicode escape sequences are
      malformed.
 */
- (NSString *)nextQuotedValueWithChar:(jchar)quote;

/*!
 @brief Returns an unquoted value as a string.
 */
- (NSString *)nextUnquotedValue;

- (void)skipQuotedValueWithChar:(jchar)quote;

- (void)skipUnquotedValue;

- (void)pushWithInt:(jint)newTop;

/*!
 @brief Returns true once <code>limit - pos >= minimum</code>.If the data is
  exhausted before that many characters are available, this returns
  false.
 */
- (jboolean)fillBufferWithInt:(jint)minimum;

/*!
 @brief Returns the next character in the stream that is neither whitespace nor a
  part of a comment.When this returns, the returned character is always at 
 <code>buffer[pos-1]</code>; this means the caller can always push back the
  returned character by decrementing <code>pos</code>.
 */
- (jint)nextNonWhitespaceWithBoolean:(jboolean)throwOnEof;

- (void)checkLenient;

/*!
 @brief Advances the position until after the next newline character.If the line
  is terminated by "\r\n", the '\n' must be consumed as whitespace by the
  caller.
 */
- (void)skipToEndOfLine;

/*!
 @param toFind a string to search for. Must not contain a newline.
 */
- (jboolean)skipToWithNSString:(NSString *)toFind;

- (NSString *)locationString;

/*!
 @brief Unescapes the character identified by the character or characters that
  immediately follow a backslash.The backslash '\' should have already
  been read.
 This supports both unicode escapes "u000A" and two-character
  escapes "\n".
 @throw NumberFormatExceptionif any unicode escape sequences are
      malformed.
 */
- (jchar)readEscapeCharacter;

/*!
 @brief Throws a new IO exception with the given message and a context snippet
  with this reader's content.
 */
- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message;

/*!
 @brief Consumes the non-execute prefix if it exists.
 */
- (void)consumeNonExecutePrefix;

@end

J2OBJC_FIELD_SETTER(GsonJsonReader, in_, JavaIoReader *)
J2OBJC_FIELD_SETTER(GsonJsonReader, buffer_, IOSCharArray *)
J2OBJC_FIELD_SETTER(GsonJsonReader, peekedString_, NSString *)
J2OBJC_FIELD_SETTER(GsonJsonReader, stack_, IOSIntArray *)
J2OBJC_FIELD_SETTER(GsonJsonReader, pathNames_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GsonJsonReader, pathIndices_, IOSIntArray *)

/*!
 @brief The only non-execute prefix this parser permits
 */
inline IOSCharArray *GsonJsonReader_get_NON_EXECUTE_PREFIX(void);
static IOSCharArray *GsonJsonReader_NON_EXECUTE_PREFIX;
J2OBJC_STATIC_FIELD_OBJ_FINAL(GsonJsonReader, NON_EXECUTE_PREFIX, IOSCharArray *)

inline jlong GsonJsonReader_get_MIN_INCOMPLETE_INTEGER(void);
#define GsonJsonReader_MIN_INCOMPLETE_INTEGER -922337203685477580LL
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, MIN_INCOMPLETE_INTEGER, jlong)

inline jint GsonJsonReader_get_PEEKED_NONE(void);
#define GsonJsonReader_PEEKED_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_NONE, jint)

inline jint GsonJsonReader_get_PEEKED_BEGIN_OBJECT(void);
#define GsonJsonReader_PEEKED_BEGIN_OBJECT 1
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_BEGIN_OBJECT, jint)

inline jint GsonJsonReader_get_PEEKED_END_OBJECT(void);
#define GsonJsonReader_PEEKED_END_OBJECT 2
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_END_OBJECT, jint)

inline jint GsonJsonReader_get_PEEKED_BEGIN_ARRAY(void);
#define GsonJsonReader_PEEKED_BEGIN_ARRAY 3
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_BEGIN_ARRAY, jint)

inline jint GsonJsonReader_get_PEEKED_END_ARRAY(void);
#define GsonJsonReader_PEEKED_END_ARRAY 4
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_END_ARRAY, jint)

inline jint GsonJsonReader_get_PEEKED_TRUE(void);
#define GsonJsonReader_PEEKED_TRUE 5
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_TRUE, jint)

inline jint GsonJsonReader_get_PEEKED_FALSE(void);
#define GsonJsonReader_PEEKED_FALSE 6
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_FALSE, jint)

inline jint GsonJsonReader_get_PEEKED_NULL(void);
#define GsonJsonReader_PEEKED_NULL 7
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_NULL, jint)

inline jint GsonJsonReader_get_PEEKED_SINGLE_QUOTED(void);
#define GsonJsonReader_PEEKED_SINGLE_QUOTED 8
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_SINGLE_QUOTED, jint)

inline jint GsonJsonReader_get_PEEKED_DOUBLE_QUOTED(void);
#define GsonJsonReader_PEEKED_DOUBLE_QUOTED 9
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_DOUBLE_QUOTED, jint)

inline jint GsonJsonReader_get_PEEKED_UNQUOTED(void);
#define GsonJsonReader_PEEKED_UNQUOTED 10
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_UNQUOTED, jint)

/*!
 @brief When this is returned, the string value is stored in peekedString.
 */
inline jint GsonJsonReader_get_PEEKED_BUFFERED(void);
#define GsonJsonReader_PEEKED_BUFFERED 11
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_BUFFERED, jint)

inline jint GsonJsonReader_get_PEEKED_SINGLE_QUOTED_NAME(void);
#define GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME 12
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_SINGLE_QUOTED_NAME, jint)

inline jint GsonJsonReader_get_PEEKED_DOUBLE_QUOTED_NAME(void);
#define GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME 13
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_DOUBLE_QUOTED_NAME, jint)

inline jint GsonJsonReader_get_PEEKED_UNQUOTED_NAME(void);
#define GsonJsonReader_PEEKED_UNQUOTED_NAME 14
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_UNQUOTED_NAME, jint)

/*!
 @brief When this is returned, the integer value is stored in peekedLong.
 */
inline jint GsonJsonReader_get_PEEKED_LONG(void);
#define GsonJsonReader_PEEKED_LONG 15
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_LONG, jint)

inline jint GsonJsonReader_get_PEEKED_NUMBER(void);
#define GsonJsonReader_PEEKED_NUMBER 16
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_NUMBER, jint)

inline jint GsonJsonReader_get_PEEKED_EOF(void);
#define GsonJsonReader_PEEKED_EOF 17
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_EOF, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_NONE(void);
#define GsonJsonReader_NUMBER_CHAR_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_NONE, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_SIGN(void);
#define GsonJsonReader_NUMBER_CHAR_SIGN 1
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_SIGN, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_DIGIT(void);
#define GsonJsonReader_NUMBER_CHAR_DIGIT 2
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_DIGIT, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_DECIMAL(void);
#define GsonJsonReader_NUMBER_CHAR_DECIMAL 3
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_DECIMAL, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_FRACTION_DIGIT(void);
#define GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT 4
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_FRACTION_DIGIT, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_EXP_E(void);
#define GsonJsonReader_NUMBER_CHAR_EXP_E 5
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_EXP_E, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_EXP_SIGN(void);
#define GsonJsonReader_NUMBER_CHAR_EXP_SIGN 6
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_EXP_SIGN, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_EXP_DIGIT(void);
#define GsonJsonReader_NUMBER_CHAR_EXP_DIGIT 7
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_EXP_DIGIT, jint)

__attribute__((unused)) static jint GsonJsonReader_peekKeyword(GsonJsonReader *self);

__attribute__((unused)) static jint GsonJsonReader_peekNumber(GsonJsonReader *self);

__attribute__((unused)) static jboolean GsonJsonReader_isLiteralWithChar_(GsonJsonReader *self, jchar c);

__attribute__((unused)) static NSString *GsonJsonReader_nextQuotedValueWithChar_(GsonJsonReader *self, jchar quote);

__attribute__((unused)) static NSString *GsonJsonReader_nextUnquotedValue(GsonJsonReader *self);

__attribute__((unused)) static void GsonJsonReader_skipQuotedValueWithChar_(GsonJsonReader *self, jchar quote);

__attribute__((unused)) static void GsonJsonReader_skipUnquotedValue(GsonJsonReader *self);

__attribute__((unused)) static void GsonJsonReader_pushWithInt_(GsonJsonReader *self, jint newTop);

__attribute__((unused)) static jboolean GsonJsonReader_fillBufferWithInt_(GsonJsonReader *self, jint minimum);

__attribute__((unused)) static jint GsonJsonReader_nextNonWhitespaceWithBoolean_(GsonJsonReader *self, jboolean throwOnEof);

__attribute__((unused)) static void GsonJsonReader_checkLenient(GsonJsonReader *self);

__attribute__((unused)) static void GsonJsonReader_skipToEndOfLine(GsonJsonReader *self);

__attribute__((unused)) static jboolean GsonJsonReader_skipToWithNSString_(GsonJsonReader *self, NSString *toFind);

__attribute__((unused)) static NSString *GsonJsonReader_locationString(GsonJsonReader *self);

__attribute__((unused)) static jchar GsonJsonReader_readEscapeCharacter(GsonJsonReader *self);

__attribute__((unused)) static JavaIoIOException *GsonJsonReader_syntaxErrorWithNSString_(GsonJsonReader *self, NSString *message);

__attribute__((unused)) static void GsonJsonReader_consumeNonExecutePrefix(GsonJsonReader *self);

@interface GsonJsonReader_1 : GsonJsonReaderInternalAccess

- (instancetype)init;

- (void)promoteNameToValueWithGsonJsonReader:(GsonJsonReader *)reader;

@end

J2OBJC_EMPTY_STATIC_INIT(GsonJsonReader_1)

__attribute__((unused)) static void GsonJsonReader_1_init(GsonJsonReader_1 *self);

__attribute__((unused)) static GsonJsonReader_1 *new_GsonJsonReader_1_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static GsonJsonReader_1 *create_GsonJsonReader_1_init(void);

#line 1 "/Users/ahmedmohammed/intelliJWorkspace/employee-gson/src/main/java/com/google/gson/stream/JsonReader.java"

J2OBJC_INITIALIZED_DEFN(GsonJsonReader)


#line 190
@implementation GsonJsonReader


#line 289
- (instancetype)initWithJavaIoReader:(JavaIoReader *)inArg {
  GsonJsonReader_initWithJavaIoReader_(self, inArg);
  return self;
}


#line 325
- (void)setLenientWithBoolean:(jboolean)lenient {
  self->lenient_ = lenient;
}


#line 332
- (jboolean)isLenient {
  return lenient_;
}


#line 340
- (void)beginArray {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_BEGIN_ARRAY) {
    GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_ARRAY);
    *IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1) = 0;
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    
#line 350
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected BEGIN_ARRAY but was ", [self peek], GsonJsonReader_locationString(self)));
  }
}


#line 358
- (void)endArray {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_END_ARRAY) {
    stackSize_--;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    
#line 368
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected END_ARRAY but was ", [self peek], GsonJsonReader_locationString(self)));
  }
}


#line 376
- (void)beginObject {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_BEGIN_OBJECT) {
    GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_OBJECT);
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    
#line 385
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected BEGIN_OBJECT but was ", [self peek], GsonJsonReader_locationString(self)));
  }
}


#line 393
- (void)endObject {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_END_OBJECT) {
    stackSize_--;
    (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_, nil);
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    
#line 404
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected END_OBJECT but was ", [self peek], GsonJsonReader_locationString(self)));
  }
}

- (jboolean)hasNext {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  return p != GsonJsonReader_PEEKED_END_OBJECT && p != GsonJsonReader_PEEKED_END_ARRAY;
}


#line 422
- (GsonJsonToken *)peek {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  
#line 428
  switch (p) {
    case GsonJsonReader_PEEKED_BEGIN_OBJECT:
    return JreLoadEnum(GsonJsonToken, BEGIN_OBJECT);
    case GsonJsonReader_PEEKED_END_OBJECT:
    return JreLoadEnum(GsonJsonToken, END_OBJECT);
    case GsonJsonReader_PEEKED_BEGIN_ARRAY:
    return JreLoadEnum(GsonJsonToken, BEGIN_ARRAY);
    case GsonJsonReader_PEEKED_END_ARRAY:
    return JreLoadEnum(GsonJsonToken, END_ARRAY);
    case GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME:
    case GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME:
    case GsonJsonReader_PEEKED_UNQUOTED_NAME:
    return JreLoadEnum(GsonJsonToken, NAME);
    case GsonJsonReader_PEEKED_TRUE:
    case GsonJsonReader_PEEKED_FALSE:
    return JreLoadEnum(GsonJsonToken, BOOLEAN);
    case GsonJsonReader_PEEKED_NULL:
    return JreLoadEnum(GsonJsonToken, NULL);
    case GsonJsonReader_PEEKED_SINGLE_QUOTED:
    case GsonJsonReader_PEEKED_DOUBLE_QUOTED:
    case GsonJsonReader_PEEKED_UNQUOTED:
    case GsonJsonReader_PEEKED_BUFFERED:
    return JreLoadEnum(GsonJsonToken, STRING);
    case GsonJsonReader_PEEKED_LONG:
    case GsonJsonReader_PEEKED_NUMBER:
    return JreLoadEnum(GsonJsonToken, NUMBER);
    case GsonJsonReader_PEEKED_EOF:
    return JreLoadEnum(GsonJsonToken, END_DOCUMENT);
    default:
    @throw new_JavaLangAssertionError_init();
  }
}


#line 461
- (jint)doPeek {
  jint peekStack = IOSIntArray_Get(nil_chk(stack_), stackSize_ - 1);
  if (peekStack == GsonJsonScope_EMPTY_ARRAY) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GsonJsonScope_NONEMPTY_ARRAY;
  }
  else
#line 465
  if (peekStack == GsonJsonScope_NONEMPTY_ARRAY) {
    
#line 467
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case ']':
      return peeked_ = GsonJsonReader_PEEKED_END_ARRAY;
      case ';':
      GsonJsonReader_checkLenient(self);
      case ',':
      break;
      default:
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated array"));
    }
  }
  else
#line 478
  if (peekStack == GsonJsonScope_EMPTY_OBJECT || peekStack == GsonJsonScope_NONEMPTY_OBJECT) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GsonJsonScope_DANGLING_NAME;
    
#line 481
    if (peekStack == GsonJsonScope_NONEMPTY_OBJECT) {
      jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
      switch (c) {
        case '}':
        return peeked_ = GsonJsonReader_PEEKED_END_OBJECT;
        case ';':
        GsonJsonReader_checkLenient(self);
        case ',':
        break;
        default:
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated object"));
      }
    }
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case '"':
      return peeked_ = GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME;
      case '\'':
      GsonJsonReader_checkLenient(self);
      return peeked_ = GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME;
      case '}':
      if (peekStack != GsonJsonScope_NONEMPTY_OBJECT) {
        return peeked_ = GsonJsonReader_PEEKED_END_OBJECT;
      }
      else {
        
#line 505
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected name"));
      }
      default:
      GsonJsonReader_checkLenient(self);
      pos_--;
      if (GsonJsonReader_isLiteralWithChar_(self, (jchar) c)) {
        return peeked_ = GsonJsonReader_PEEKED_UNQUOTED_NAME;
      }
      else {
        
#line 513
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected name"));
      }
    }
  }
  else
#line 516
  if (peekStack == GsonJsonScope_DANGLING_NAME) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GsonJsonScope_NONEMPTY_OBJECT;
    
#line 519
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case ':':
      break;
      case '=':
      GsonJsonReader_checkLenient(self);
      if ((pos_ < limit_ || GsonJsonReader_fillBufferWithInt_(self, 1)) && IOSCharArray_Get(nil_chk(buffer_), pos_) == '>') {
        pos_++;
      }
      break;
      default:
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected ':'"));
    }
  }
  else
#line 532
  if (peekStack == GsonJsonScope_EMPTY_DOCUMENT) {
    if (lenient_) {
      GsonJsonReader_consumeNonExecutePrefix(self);
    }
    *IOSIntArray_GetRef(nil_chk(stack_), stackSize_ - 1) = GsonJsonScope_NONEMPTY_DOCUMENT;
  }
  else
#line 537
  if (peekStack == GsonJsonScope_NONEMPTY_DOCUMENT) {
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, false);
    if (c == -1) {
      return peeked_ = GsonJsonReader_PEEKED_EOF;
    }
    else {
      
#line 542
      GsonJsonReader_checkLenient(self);
      pos_--;
    }
  }
  else
#line 545
  if (peekStack == GsonJsonScope_CLOSED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"JsonReader is closed");
  }
  
#line 549
  jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
  switch (c) {
    case ']':
    if (peekStack == GsonJsonScope_EMPTY_ARRAY) {
      return peeked_ = GsonJsonReader_PEEKED_END_ARRAY;
    }
    
#line 556
    case ';':
    case ',':
    
#line 559
    if (peekStack == GsonJsonScope_EMPTY_ARRAY || peekStack == GsonJsonScope_NONEMPTY_ARRAY) {
      GsonJsonReader_checkLenient(self);
      pos_--;
      return peeked_ = GsonJsonReader_PEEKED_NULL;
    }
    else {
      
#line 564
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unexpected value"));
    }
    case '\'':
    GsonJsonReader_checkLenient(self);
    return peeked_ = GsonJsonReader_PEEKED_SINGLE_QUOTED;
    case '"':
    return peeked_ = GsonJsonReader_PEEKED_DOUBLE_QUOTED;
    case '[':
    return peeked_ = GsonJsonReader_PEEKED_BEGIN_ARRAY;
    case '{':
    return peeked_ = GsonJsonReader_PEEKED_BEGIN_OBJECT;
    default:
    pos_--;
  }
  
#line 579
  jint result = GsonJsonReader_peekKeyword(self);
  if (result != GsonJsonReader_PEEKED_NONE) {
    return result;
  }
  
#line 584
  result = GsonJsonReader_peekNumber(self);
  if (result != GsonJsonReader_PEEKED_NONE) {
    return result;
  }
  
#line 589
  if (!GsonJsonReader_isLiteralWithChar_(self, IOSCharArray_Get(nil_chk(buffer_), pos_))) {
    @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected value"));
  }
  
#line 593
  GsonJsonReader_checkLenient(self);
  return peeked_ = GsonJsonReader_PEEKED_UNQUOTED;
}


#line 597
- (jint)peekKeyword {
  return GsonJsonReader_peekKeyword(self);
}


#line 641
- (jint)peekNumber {
  return GsonJsonReader_peekNumber(self);
}


#line 744
- (jboolean)isLiteralWithChar:(jchar)c {
  return GsonJsonReader_isLiteralWithChar_(self, c);
}


#line 776
- (NSString *)nextName {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  NSString *result;
  if (p == GsonJsonReader_PEEKED_UNQUOTED_NAME) {
    result = GsonJsonReader_nextUnquotedValue(self);
  }
  else
#line 784
  if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '\'');
  }
  else
#line 786
  if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '"');
  }
  else {
    
#line 789
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a name but was ", [self peek], GsonJsonReader_locationString(self)));
  }
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_ - 1, result);
  return result;
}


#line 804
- (NSString *)nextString {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  NSString *result;
  if (p == GsonJsonReader_PEEKED_UNQUOTED) {
    result = GsonJsonReader_nextUnquotedValue(self);
  }
  else
#line 812
  if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '\'');
  }
  else
#line 814
  if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '"');
  }
  else
#line 816
  if (p == GsonJsonReader_PEEKED_BUFFERED) {
    result = peekedString_;
    peekedString_ = nil;
  }
  else
#line 819
  if (p == GsonJsonReader_PEEKED_LONG) {
    result = JavaLangLong_toStringWithLong_(peekedLong_);
  }
  else
#line 821
  if (p == GsonJsonReader_PEEKED_NUMBER) {
    result = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else {
    
#line 825
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a string but was ", [self peek], GsonJsonReader_locationString(self)));
  }
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}


#line 839
- (jboolean)nextBoolean {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_TRUE) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return true;
  }
  else
#line 848
  if (p == GsonJsonReader_PEEKED_FALSE) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return false;
  }
  @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a boolean but was ", [self peek], GsonJsonReader_locationString(self)));
}


#line 863
- (void)nextNull {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_NULL) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  }
  else {
    
#line 872
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected null but was ", [self peek], GsonJsonReader_locationString(self)));
  }
}


#line 885
- (jdouble)nextDouble {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  
#line 891
  if (p == GsonJsonReader_PEEKED_LONG) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return (jdouble) peekedLong_;
  }
  
#line 897
  if (p == GsonJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else
#line 900
  if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED) {
    peekedString_ = GsonJsonReader_nextQuotedValueWithChar_(self, p == GsonJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
  }
  else
#line 902
  if (p == GsonJsonReader_PEEKED_UNQUOTED) {
    peekedString_ = GsonJsonReader_nextUnquotedValue(self);
  }
  else
#line 904
  if (p != GsonJsonReader_PEEKED_BUFFERED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a double but was ", [self peek], GsonJsonReader_locationString(self)));
  }
  
#line 908
  peeked_ = GsonJsonReader_PEEKED_BUFFERED;
  jdouble result = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  if (!lenient_ && (JavaLangDouble_isNaNWithDouble_(result) || JavaLangDouble_isInfiniteWithDouble_(result))) {
    @throw new_GsonMalformedJsonException_initWithNSString_(JreStrcat("$D$", @"JSON forbids NaN and infinities: ",
#line 912
    result, GsonJsonReader_locationString(self)));
  }
  peekedString_ = nil;
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}


#line 930
- (jlong)nextLong {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  
#line 936
  if (p == GsonJsonReader_PEEKED_LONG) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return peekedLong_;
  }
  
#line 942
  if (p == GsonJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else
#line 945
  if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED || p == GsonJsonReader_PEEKED_UNQUOTED) {
    if (p == GsonJsonReader_PEEKED_UNQUOTED) {
      peekedString_ = GsonJsonReader_nextUnquotedValue(self);
    }
    else {
      
#line 949
      peekedString_ = GsonJsonReader_nextQuotedValueWithChar_(self, p == GsonJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
    }
    @try {
      jlong result = JavaLangLong_parseLongWithNSString_(peekedString_);
      peeked_ = GsonJsonReader_PEEKED_NONE;
      (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
      return result;
    }
    @catch (
#line 956
    JavaLangNumberFormatException *ignored) {
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a long but was ", [self peek], GsonJsonReader_locationString(self)));
  }
  
#line 963
  peeked_ = GsonJsonReader_PEEKED_BUFFERED;
  jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  jlong result = JreFpToLong(asDouble);
  if (result != asDouble) {
    @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$$", @"Expected a long but was ", peekedString_, GsonJsonReader_locationString(self)));
  }
  peekedString_ = nil;
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}


#line 985
- (NSString *)nextQuotedValueWithChar:(jchar)quote {
  return GsonJsonReader_nextQuotedValueWithChar_(self, quote);
}


#line 1025
- (NSString *)nextUnquotedValue {
  return GsonJsonReader_nextUnquotedValue(self);
}


#line 1087
- (void)skipQuotedValueWithChar:(jchar)quote {
  GsonJsonReader_skipQuotedValueWithChar_(self, quote);
}


#line 1114
- (void)skipUnquotedValue {
  GsonJsonReader_skipUnquotedValue(self);
}


#line 1154
- (jint)nextInt {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  
#line 1160
  jint result;
  if (p == GsonJsonReader_PEEKED_LONG) {
    result = (jint) peekedLong_;
    if (peekedLong_ != result) {
      @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$J$", @"Expected an int but was ", peekedLong_, GsonJsonReader_locationString(self)));
    }
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return result;
  }
  
#line 1171
  if (p == GsonJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else
#line 1174
  if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED || p == GsonJsonReader_PEEKED_UNQUOTED) {
    if (p == GsonJsonReader_PEEKED_UNQUOTED) {
      peekedString_ = GsonJsonReader_nextUnquotedValue(self);
    }
    else {
      
#line 1178
      peekedString_ = GsonJsonReader_nextQuotedValueWithChar_(self, p == GsonJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
    }
    @try {
      result = JavaLangInteger_parseIntWithNSString_(peekedString_);
      peeked_ = GsonJsonReader_PEEKED_NONE;
      (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
      return result;
    }
    @catch (
#line 1185
    JavaLangNumberFormatException *ignored) {
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected an int but was ", [self peek], GsonJsonReader_locationString(self)));
  }
  
#line 1192
  peeked_ = GsonJsonReader_PEEKED_BUFFERED;
  jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  result = JreFpToInt(asDouble);
  if (result != asDouble) {
    @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$$", @"Expected an int but was ", peekedString_, GsonJsonReader_locationString(self)));
  }
  peekedString_ = nil;
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}


#line 1207
- (void)close {
  peeked_ = GsonJsonReader_PEEKED_NONE;
  *IOSIntArray_GetRef(nil_chk(stack_), 0) = GsonJsonScope_CLOSED;
  stackSize_ = 1;
  [((JavaIoReader *) nil_chk(in_)) close];
}


#line 1219
- (void)skipValue {
  jint count = 0;
  do {
    jint p = peeked_;
    if (p == GsonJsonReader_PEEKED_NONE) {
      p = [self doPeek];
    }
    
#line 1227
    if (p == GsonJsonReader_PEEKED_BEGIN_ARRAY) {
      GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_ARRAY);
      count++;
    }
    else
#line 1230
    if (p == GsonJsonReader_PEEKED_BEGIN_OBJECT) {
      GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_OBJECT);
      count++;
    }
    else
#line 1233
    if (p == GsonJsonReader_PEEKED_END_ARRAY) {
      stackSize_--;
      count--;
    }
    else
#line 1236
    if (p == GsonJsonReader_PEEKED_END_OBJECT) {
      stackSize_--;
      count--;
    }
    else
#line 1239
    if (p == GsonJsonReader_PEEKED_UNQUOTED_NAME || p == GsonJsonReader_PEEKED_UNQUOTED) {
      GsonJsonReader_skipUnquotedValue(self);
    }
    else
#line 1241
    if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
      GsonJsonReader_skipQuotedValueWithChar_(self, '\'');
    }
    else
#line 1243
    if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
      GsonJsonReader_skipQuotedValueWithChar_(self, '"');
    }
    else
#line 1245
    if (p == GsonJsonReader_PEEKED_NUMBER) {
      pos_ += peekedNumberLength_;
    }
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  while (
#line 1249
  count != 0);
  
#line 1251
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_ - 1, @"null");
}


#line 1255
- (void)pushWithInt:(jint)newTop {
  GsonJsonReader_pushWithInt_(self, newTop);
}


#line 1275
- (jboolean)fillBufferWithInt:(jint)minimum {
  return GsonJsonReader_fillBufferWithInt_(self, minimum);
}


#line 1310
- (jint)nextNonWhitespaceWithBoolean:(jboolean)throwOnEof {
  return GsonJsonReader_nextNonWhitespaceWithBoolean_(self, throwOnEof);
}


#line 1399
- (void)checkLenient {
  GsonJsonReader_checkLenient(self);
}


#line 1410
- (void)skipToEndOfLine {
  GsonJsonReader_skipToEndOfLine(self);
}


#line 1426
- (jboolean)skipToWithNSString:(NSString *)toFind {
  return GsonJsonReader_skipToWithNSString_(self, toFind);
}


#line 1444
- (NSString *)description {
  return JreStrcat("$$", [[self java_getClass] getSimpleName], GsonJsonReader_locationString(self));
}

- (NSString *)locationString {
  return GsonJsonReader_locationString(self);
}


#line 1458
- (NSString *)getPath {
  JavaLangStringBuilder *result = [new_JavaLangStringBuilder_init() appendWithChar:'$'];
  for (jint i = 0, size = stackSize_; i < size; i++) {
    switch (IOSIntArray_Get(nil_chk(stack_), i)) {
      case GsonJsonScope_EMPTY_ARRAY:
      case GsonJsonScope_NONEMPTY_ARRAY:
      (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk(result)) appendWithChar:'['])) appendWithInt:IOSIntArray_Get(nil_chk(pathIndices_), i)])) appendWithChar:']'];
      break;
      
#line 1467
      case GsonJsonScope_EMPTY_OBJECT:
      case GsonJsonScope_DANGLING_NAME:
      case GsonJsonScope_NONEMPTY_OBJECT:
      (void) [((JavaLangStringBuilder *) nil_chk(result)) appendWithChar:'.'];
      if (IOSObjectArray_Get(nil_chk(pathNames_), i) != nil) {
        (void) [result appendWithNSString:IOSObjectArray_Get(pathNames_, i)];
      }
      break;
      
#line 1476
      case GsonJsonScope_NONEMPTY_DOCUMENT:
      case GsonJsonScope_EMPTY_DOCUMENT:
      case GsonJsonScope_CLOSED:
      break;
    }
  }
  return [((JavaLangStringBuilder *) nil_chk(result)) description];
}


#line 1494
- (jchar)readEscapeCharacter {
  return GsonJsonReader_readEscapeCharacter(self);
}


#line 1558
- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message {
  return GsonJsonReader_syntaxErrorWithNSString_(self, message);
}


#line 1565
- (void)consumeNonExecutePrefix {
  GsonJsonReader_consumeNonExecutePrefix(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LGsonJsonToken;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 4, 5, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "D", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 6, 5, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 7, 5, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 10, 9, 3, -1, -1, -1 },
    { NULL, "I", 0x2, 11, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 12, 13, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 14, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "C", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LJavaIoIOException;", 0x2, 15, 13, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoReader:);
  methods[1].selector = @selector(setLenientWithBoolean:);
  methods[2].selector = @selector(isLenient);
  methods[3].selector = @selector(beginArray);
  methods[4].selector = @selector(endArray);
  methods[5].selector = @selector(beginObject);
  methods[6].selector = @selector(endObject);
  methods[7].selector = @selector(hasNext);
  methods[8].selector = @selector(peek);
  methods[9].selector = @selector(doPeek);
  methods[10].selector = @selector(peekKeyword);
  methods[11].selector = @selector(peekNumber);
  methods[12].selector = @selector(isLiteralWithChar:);
  methods[13].selector = @selector(nextName);
  methods[14].selector = @selector(nextString);
  methods[15].selector = @selector(nextBoolean);
  methods[16].selector = @selector(nextNull);
  methods[17].selector = @selector(nextDouble);
  methods[18].selector = @selector(nextLong);
  methods[19].selector = @selector(nextQuotedValueWithChar:);
  methods[20].selector = @selector(nextUnquotedValue);
  methods[21].selector = @selector(skipQuotedValueWithChar:);
  methods[22].selector = @selector(skipUnquotedValue);
  methods[23].selector = @selector(nextInt);
  methods[24].selector = @selector(close);
  methods[25].selector = @selector(skipValue);
  methods[26].selector = @selector(pushWithInt:);
  methods[27].selector = @selector(fillBufferWithInt:);
  methods[28].selector = @selector(nextNonWhitespaceWithBoolean:);
  methods[29].selector = @selector(checkLenient);
  methods[30].selector = @selector(skipToEndOfLine);
  methods[31].selector = @selector(skipToWithNSString:);
  methods[32].selector = @selector(description);
  methods[33].selector = @selector(locationString);
  methods[34].selector = @selector(getPath);
  methods[35].selector = @selector(readEscapeCharacter);
  methods[36].selector = @selector(syntaxErrorWithNSString:);
  methods[37].selector = @selector(consumeNonExecutePrefix);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NON_EXECUTE_PREFIX", "[C", .constantValue.asLong = 0, 0x1a, -1, 16, -1, -1 },
    { "MIN_INCOMPLETE_INTEGER", "J", .constantValue.asLong = GsonJsonReader_MIN_INCOMPLETE_INTEGER, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NONE", "I", .constantValue.asInt = GsonJsonReader_PEEKED_NONE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BEGIN_OBJECT", "I", .constantValue.asInt = GsonJsonReader_PEEKED_BEGIN_OBJECT, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_END_OBJECT", "I", .constantValue.asInt = GsonJsonReader_PEEKED_END_OBJECT, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BEGIN_ARRAY", "I", .constantValue.asInt = GsonJsonReader_PEEKED_BEGIN_ARRAY, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_END_ARRAY", "I", .constantValue.asInt = GsonJsonReader_PEEKED_END_ARRAY, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_TRUE", "I", .constantValue.asInt = GsonJsonReader_PEEKED_TRUE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_FALSE", "I", .constantValue.asInt = GsonJsonReader_PEEKED_FALSE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NULL", "I", .constantValue.asInt = GsonJsonReader_PEEKED_NULL, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_SINGLE_QUOTED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_SINGLE_QUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_DOUBLE_QUOTED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_DOUBLE_QUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_UNQUOTED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_UNQUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BUFFERED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_BUFFERED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_SINGLE_QUOTED_NAME", "I", .constantValue.asInt = GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_DOUBLE_QUOTED_NAME", "I", .constantValue.asInt = GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_UNQUOTED_NAME", "I", .constantValue.asInt = GsonJsonReader_PEEKED_UNQUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_LONG", "I", .constantValue.asInt = GsonJsonReader_PEEKED_LONG, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NUMBER", "I", .constantValue.asInt = GsonJsonReader_PEEKED_NUMBER, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_EOF", "I", .constantValue.asInt = GsonJsonReader_PEEKED_EOF, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_NONE", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_NONE, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_SIGN", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_SIGN, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_DIGIT", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_DECIMAL", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_DECIMAL, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_FRACTION_DIGIT", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_E", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_EXP_E, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_SIGN", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_EXP_SIGN, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_DIGIT", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_EXP_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "in_", "LJavaIoReader;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "lenient_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[C", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "limit_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineNumber_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineStart_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peeked_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "peekedLong_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peekedNumberLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peekedString_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stack_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stackSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pathNames_", "[LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pathIndices_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoReader;", "setLenient", "Z", "LJavaIoIOException;", "isLiteral", "C", "nextQuotedValue", "skipQuotedValue", "push", "I", "fillBuffer", "nextNonWhitespace", "skipTo", "LNSString;", "toString", "syntaxError", &GsonJsonReader_NON_EXECUTE_PREFIX };
  static const J2ObjcClassInfo _GsonJsonReader = { "JsonReader", "com.google.gson.stream", ptrTable, methods, fields, 7, 0x1, 38, 43, -1, -1, -1, -1, -1 };
  return &_GsonJsonReader;
}

+ (void)initialize {
  if (self == [GsonJsonReader class]) {
    GsonJsonReader_NON_EXECUTE_PREFIX =
#line 192
    [@")]}'\n" java_toCharArray];
    {
      
#line 1585
      *JreLoadStaticRef(GsonJsonReaderInternalAccess, INSTANCE) = new_GsonJsonReader_1_init();
    }
    J2OBJC_SET_INITIALIZED(GsonJsonReader)
  }
}

@end


#line 289
void GsonJsonReader_initWithJavaIoReader_(GsonJsonReader *self, JavaIoReader *inArg) {
  NSObject_init(self);
  self->lenient_ =
#line 230
  false;
  self->buffer_ = [IOSCharArray newArrayWithLength:
#line 238
  1024];
  self->pos_ = 0;
  self->limit_ = 0;
  self->lineNumber_ =
#line 242
  0;
  self->lineStart_ = 0;
  self->peeked_ = GsonJsonReader_PEEKED_NONE;
  self->stack_ = [IOSIntArray newArrayWithLength:
#line 269
  32];
  self->stackSize_ = 0;
  {
    *IOSIntArray_GetRef(self->stack_, self->stackSize_++) = GsonJsonScope_EMPTY_DOCUMENT;
  }
  self->pathNames_ = [IOSObjectArray newArrayWithLength:
#line 283
  32 type:NSString_class_()];
  self->pathIndices_ = [IOSIntArray newArrayWithLength:32];
  
#line 290
  if (inArg == nil) {
    @throw new_JavaLangNullPointerException_initWithNSString_(@"in == null");
  }
  self->in_ = inArg;
}


#line 289
GsonJsonReader *new_GsonJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_NEW_IMPL(GsonJsonReader, initWithJavaIoReader_, inArg)
}


#line 289
GsonJsonReader *create_GsonJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_CREATE_IMPL(GsonJsonReader, initWithJavaIoReader_, inArg)
}


#line 597
jint GsonJsonReader_peekKeyword(GsonJsonReader *self) {
  
#line 599
  jchar c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_);
  NSString *keyword;
  NSString *keywordUpper;
  jint peeking;
  if (c == 't' || c == 'T') {
    keyword = @"true";
    keywordUpper = @"TRUE";
    peeking = GsonJsonReader_PEEKED_TRUE;
  }
  else
#line 607
  if (c == 'f' || c == 'F') {
    keyword = @"false";
    keywordUpper = @"FALSE";
    peeking = GsonJsonReader_PEEKED_FALSE;
  }
  else
#line 611
  if (c == 'n' || c == 'N') {
    keyword = @"null";
    keywordUpper = @"NULL";
    peeking = GsonJsonReader_PEEKED_NULL;
  }
  else {
    
#line 616
    return GsonJsonReader_PEEKED_NONE;
  }
  
#line 620
  jint length = [keyword java_length];
  for (jint i = 1; i < length; i++) {
    if (self->pos_ + i >= self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, i + 1)) {
      return GsonJsonReader_PEEKED_NONE;
    }
    c = IOSCharArray_Get(self->buffer_, self->pos_ + i);
    if (c != [keyword charAtWithInt:i] && c != [keywordUpper charAtWithInt:i]) {
      return GsonJsonReader_PEEKED_NONE;
    }
  }
  
#line 631
  if ((self->pos_ + length < self->limit_ || GsonJsonReader_fillBufferWithInt_(self, length + 1)) && GsonJsonReader_isLiteralWithChar_(self, IOSCharArray_Get(self->buffer_,
#line 632
  self->pos_ + length))) {
    return GsonJsonReader_PEEKED_NONE;
  }
  
#line 637
  self->pos_ += length;
  return self->peeked_ = peeking;
}


#line 641
jint GsonJsonReader_peekNumber(GsonJsonReader *self) {
  
#line 643
  IOSCharArray *buffer = self->buffer_;
  jint p = self->pos_;
  jint l = self->limit_;
  
#line 647
  jlong value = 0;
  jboolean negative = false;
  jboolean fitsInLong = true;
  jint last = GsonJsonReader_NUMBER_CHAR_NONE;
  
#line 652
  jint i = 0;
  
#line 655
  for (; true; i++) {
    if (p + i == l) {
      if (i == ((IOSCharArray *) nil_chk(buffer))->size_) {
        
#line 660
        return GsonJsonReader_PEEKED_NONE;
      }
      if (!GsonJsonReader_fillBufferWithInt_(self, i + 1)) {
        break;
      }
      p = self->pos_;
      l = self->limit_;
    }
    
#line 669
    jchar c = IOSCharArray_Get(nil_chk(buffer), p + i);
    switch (c) {
      case '-':
      if (last == GsonJsonReader_NUMBER_CHAR_NONE) {
        negative = true;
        last = GsonJsonReader_NUMBER_CHAR_SIGN;
        continue;
      }
      else
#line 676
      if (last == GsonJsonReader_NUMBER_CHAR_EXP_E) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_SIGN;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      
#line 682
      case '+':
      if (last == GsonJsonReader_NUMBER_CHAR_EXP_E) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_SIGN;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      
#line 689
      case 'e':
      case 'E':
      if (last == GsonJsonReader_NUMBER_CHAR_DIGIT || last == GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_E;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      
#line 697
      case '.':
      if (last == GsonJsonReader_NUMBER_CHAR_DIGIT) {
        last = GsonJsonReader_NUMBER_CHAR_DECIMAL;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      
#line 704
      default:
      if (c < '0' || c > '9') {
        if (!GsonJsonReader_isLiteralWithChar_(self, c)) {
          goto break_charactersOfNumber;
        }
        return GsonJsonReader_PEEKED_NONE;
      }
      if (last == GsonJsonReader_NUMBER_CHAR_SIGN || last == GsonJsonReader_NUMBER_CHAR_NONE) {
        value = -(c - '0');
        last = GsonJsonReader_NUMBER_CHAR_DIGIT;
      }
      else
#line 714
      if (last == GsonJsonReader_NUMBER_CHAR_DIGIT) {
        if (value == 0) {
          return GsonJsonReader_PEEKED_NONE;
        }
        jlong newValue = value * 10 - (c - '0');
        fitsInLong &= (value > GsonJsonReader_MIN_INCOMPLETE_INTEGER ||
#line 720
        (value == GsonJsonReader_MIN_INCOMPLETE_INTEGER && newValue < value));
        value = newValue;
      }
      else
#line 722
      if (last == GsonJsonReader_NUMBER_CHAR_DECIMAL) {
        last = GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT;
      }
      else
#line 724
      if (last == GsonJsonReader_NUMBER_CHAR_EXP_E || last == GsonJsonReader_NUMBER_CHAR_EXP_SIGN) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_DIGIT;
      }
    }
  }
  break_charactersOfNumber: ;
  
#line 731
  if (last == GsonJsonReader_NUMBER_CHAR_DIGIT && fitsInLong && (value != JavaLangLong_MIN_VALUE || negative)) {
    self->peekedLong_ = negative ? value : -value;
    self->pos_ += i;
    return self->peeked_ = GsonJsonReader_PEEKED_LONG;
  }
  else
#line 735
  if (last == GsonJsonReader_NUMBER_CHAR_DIGIT || last == GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT ||
#line 736
  last == GsonJsonReader_NUMBER_CHAR_EXP_DIGIT) {
    self->peekedNumberLength_ = i;
    return self->peeked_ = GsonJsonReader_PEEKED_NUMBER;
  }
  else {
    
#line 740
    return GsonJsonReader_PEEKED_NONE;
  }
}


#line 744
jboolean GsonJsonReader_isLiteralWithChar_(GsonJsonReader *self, jchar c) {
  switch (c) {
    case '/':
    case '\\':
    case ';':
    case '#':
    case '=':
    GsonJsonReader_checkLenient(self);
    case '{':
    case '}':
    case '[':
    case ']':
    case ':':
    case ',':
    case ' ':
    case 0x0009:
    case 0x000c:
    case 0x000d:
    case 0x000a:
    return false;
    default:
    return true;
  }
}


#line 985
NSString *GsonJsonReader_nextQuotedValueWithChar_(GsonJsonReader *self, jchar quote) {
  
#line 987
  IOSCharArray *buffer = self->buffer_;
  JavaLangStringBuilder *builder = new_JavaLangStringBuilder_init();
  while (true) {
    jint p = self->pos_;
    jint l = self->limit_;
    
#line 993
    jint start = p;
    while (p < l) {
      jint c = IOSCharArray_Get(nil_chk(buffer), p++);
      
#line 997
      if (c == quote) {
        self->pos_ = p;
        (void) [builder appendWithCharArray:buffer withInt:start withInt:p - start - 1];
        return [builder description];
      }
      else
#line 1001
      if (c == '\\') {
        self->pos_ = p;
        (void) [builder appendWithCharArray:buffer withInt:start withInt:p - start - 1];
        (void) [builder appendWithChar:GsonJsonReader_readEscapeCharacter(self)];
        p = self->pos_;
        l = self->limit_;
        start = p;
      }
      else
#line 1008
      if (c == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = p;
      }
    }
    
#line 1014
    (void) [builder appendWithCharArray:buffer withInt:start withInt:p - start];
    self->pos_ = p;
    if (!GsonJsonReader_fillBufferWithInt_(self, 1)) {
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated string"));
    }
  }
}


#line 1025
NSString *GsonJsonReader_nextUnquotedValue(GsonJsonReader *self) {
  
#line 1027
  JavaLangStringBuilder *builder = nil;
  jint i = 0;
  
#line 1031
  while (true) {
    for (; self->pos_ + i < self->limit_; i++) {
      switch (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i)) {
        case '/':
        case '\\':
        case ';':
        case '#':
        case '=':
        GsonJsonReader_checkLenient(self);
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case ',':
        case ' ':
        case 0x0009:
        case 0x000c:
        case 0x000d:
        case 0x000a:
        goto break_findNonLiteralCharacter;
      }
    }
    
#line 1056
    if (i < ((IOSCharArray *) nil_chk(self->buffer_))->size_) {
      if (GsonJsonReader_fillBufferWithInt_(self, i + 1)) {
        continue;
      }
      else {
        
#line 1060
        break;
      }
    }
    
#line 1065
    if (builder == nil) {
      builder = new_JavaLangStringBuilder_init();
    }
    (void) [builder appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i];
    self->pos_ += i;
    i = 0;
    if (!GsonJsonReader_fillBufferWithInt_(self, 1)) {
      break;
    }
  }
  break_findNonLiteralCharacter: ;
  NSString *result;
  if (builder == nil) {
    result = [NSString java_stringWithCharacters:self->buffer_ offset:self->pos_ length:i];
  }
  else {
    
#line 1080
    (void) [builder appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i];
    result = [builder description];
  }
  self->pos_ += i;
  return result;
}


#line 1087
void GsonJsonReader_skipQuotedValueWithChar_(GsonJsonReader *self, jchar quote) {
  
#line 1089
  IOSCharArray *buffer = self->buffer_;
  do {
    jint p = self->pos_;
    jint l = self->limit_;
    
#line 1094
    while (p < l) {
      jint c = IOSCharArray_Get(nil_chk(buffer), p++);
      if (c == quote) {
        self->pos_ = p;
        return;
      }
      else
#line 1099
      if (c == '\\') {
        self->pos_ = p;
        GsonJsonReader_readEscapeCharacter(self);
        p = self->pos_;
        l = self->limit_;
      }
      else
#line 1104
      if (c == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = p;
      }
    }
    self->pos_ = p;
  }
  while (GsonJsonReader_fillBufferWithInt_(self,
#line 1110
  1));
  @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated string"));
}


#line 1114
void GsonJsonReader_skipUnquotedValue(GsonJsonReader *self) {
  do {
    jint i = 0;
    for (; self->pos_ + i < self->limit_; i++) {
      switch (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i)) {
        case '/':
        case '\\':
        case ';':
        case '#':
        case '=':
        GsonJsonReader_checkLenient(self);
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case ',':
        case ' ':
        case 0x0009:
        case 0x000c:
        case 0x000d:
        case 0x000a:
        self->pos_ += i;
        return;
      }
    }
    self->pos_ += i;
  }
  while (GsonJsonReader_fillBufferWithInt_(self,
#line 1141
  1));
}


#line 1255
void GsonJsonReader_pushWithInt_(GsonJsonReader *self, jint newTop) {
  if (self->stackSize_ == ((IOSIntArray *) nil_chk(self->stack_))->size_) {
    IOSIntArray *newStack = [IOSIntArray newArrayWithLength:self->stackSize_ * 2];
    IOSIntArray *newPathIndices = [IOSIntArray newArrayWithLength:self->stackSize_ * 2];
    IOSObjectArray *newPathNames = [IOSObjectArray newArrayWithLength:self->stackSize_ * 2 type:NSString_class_()];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->stack_, 0, newStack, 0, self->stackSize_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->pathIndices_, 0, newPathIndices, 0, self->stackSize_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->pathNames_, 0, newPathNames, 0, self->stackSize_);
    self->stack_ = newStack;
    self->pathIndices_ = newPathIndices;
    self->pathNames_ = newPathNames;
  }
  *IOSIntArray_GetRef(self->stack_, self->stackSize_++) = newTop;
}


#line 1275
jboolean GsonJsonReader_fillBufferWithInt_(GsonJsonReader *self, jint minimum) {
  IOSCharArray *buffer = self->buffer_;
  self->lineStart_ -= self->pos_;
  if (self->limit_ != self->pos_) {
    self->limit_ -= self->pos_;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer, self->pos_, buffer, 0, self->limit_);
  }
  else {
    
#line 1282
    self->limit_ = 0;
  }
  
#line 1285
  self->pos_ = 0;
  jint total;
  while ((total = [((JavaIoReader *) nil_chk(self->in_)) readWithCharArray:buffer withInt:self->limit_ withInt:((IOSCharArray *) nil_chk(buffer))->size_ - self->limit_]) != -1) {
    self->limit_ += total;
    
#line 1291
    if (self->lineNumber_ == 0 && self->lineStart_ == 0 && self->limit_ > 0 && IOSCharArray_Get(buffer, 0) == 0xfeff) {
      self->pos_++;
      self->lineStart_++;
      minimum++;
    }
    
#line 1297
    if (self->limit_ >= minimum) {
      return true;
    }
  }
  return false;
}


#line 1310
jint GsonJsonReader_nextNonWhitespaceWithBoolean_(GsonJsonReader *self, jboolean throwOnEof) {
  
#line 1319
  IOSCharArray *buffer = self->buffer_;
  jint p = self->pos_;
  jint l = self->limit_;
  while (true) {
    if (p == l) {
      self->pos_ = p;
      if (!GsonJsonReader_fillBufferWithInt_(self, 1)) {
        break;
      }
      p = self->pos_;
      l = self->limit_;
    }
    
#line 1332
    jint c = IOSCharArray_Get(nil_chk(buffer), p++);
    if (c == 0x000a) {
      self->lineNumber_++;
      self->lineStart_ = p;
      continue;
    }
    else
#line 1337
    if (c == ' ' || c == 0x000d || c == 0x0009) {
      continue;
    }
    
#line 1341
    if (c == '/') {
      self->pos_ = p;
      if (p == l) {
        self->pos_--;
        jboolean charsLoaded = GsonJsonReader_fillBufferWithInt_(self, 2);
        self->pos_++;
        if (!charsLoaded) {
          return c;
        }
      }
      
#line 1352
      GsonJsonReader_checkLenient(self);
      jchar peek = IOSCharArray_Get(buffer, self->pos_);
      switch (peek) {
        case '*':
        
#line 1357
        self->pos_++;
        if (!GsonJsonReader_skipToWithNSString_(self, @"*/")) {
          @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated comment"));
        }
        p = self->pos_ + 2;
        l = self->limit_;
        continue;
        
#line 1365
        case '/':
        
#line 1367
        self->pos_++;
        GsonJsonReader_skipToEndOfLine(self);
        p = self->pos_;
        l = self->limit_;
        continue;
        
#line 1373
        default:
        return c;
      }
    }
    else
#line 1376
    if (c == '#') {
      self->pos_ = p;
      
#line 1383
      GsonJsonReader_checkLenient(self);
      GsonJsonReader_skipToEndOfLine(self);
      p = self->pos_;
      l = self->limit_;
    }
    else {
      
#line 1388
      self->pos_ = p;
      return c;
    }
  }
  if (throwOnEof) {
    @throw new_JavaIoEOFException_initWithNSString_(JreStrcat("$$", @"End of input", GsonJsonReader_locationString(self)));
  }
  else {
    
#line 1395
    return -1;
  }
}


#line 1399
void GsonJsonReader_checkLenient(GsonJsonReader *self) {
  if (!self->lenient_) {
    @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Use JsonReader.setLenient(true) to accept malformed JSON"));
  }
}


#line 1410
void GsonJsonReader_skipToEndOfLine(GsonJsonReader *self) {
  while (self->pos_ < self->limit_ || GsonJsonReader_fillBufferWithInt_(self, 1)) {
    jchar c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
    if (c == 0x000a) {
      self->lineNumber_++;
      self->lineStart_ = self->pos_;
      break;
    }
    else
#line 1417
    if (c == 0x000d) {
      break;
    }
  }
}

jboolean GsonJsonReader_skipToWithNSString_(GsonJsonReader *self, NSString *toFind) {
  
#line 1428
  for (; self->pos_ + [((NSString *) nil_chk(toFind)) java_length] <= self->limit_ || GsonJsonReader_fillBufferWithInt_(self, [toFind java_length]); self->pos_++) {
    {
      
#line 1429
      if (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_) == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = self->pos_ + 1;
        continue;
      }
      for (jint c = 0; c < [toFind java_length]; c++) {
        if (IOSCharArray_Get(self->buffer_, self->pos_ + c) != [toFind charAtWithInt:c]) {
          goto continue_outer;
        }
      }
      return true;
    }
    continue_outer: ;
  }
  
#line 1441
  return false;
}


#line 1448
NSString *GsonJsonReader_locationString(GsonJsonReader *self) {
  jint line = self->lineNumber_ + 1;
  jint column = self->pos_ - self->lineStart_ + 1;
  return JreStrcat("$I$I$$", @" at line ", line, @" column ", column, @" path ", [self getPath]);
}


#line 1494
jchar GsonJsonReader_readEscapeCharacter(GsonJsonReader *self) {
  if (self->pos_ == self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, 1)) {
    @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
  }
  
#line 1499
  jchar escaped = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
  {
    
#line 1506
    jchar result;
    
#line 1500
    switch (escaped) {
      case 'u':
      if (self->pos_ + 4 > self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, 4)) {
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
      }
      result =
#line 1506
      0;
      for (jint i = self->pos_, end = i + 4; i < end; i++) {
        jchar c = IOSCharArray_Get(self->buffer_, i);
        JreLShiftAssignChar(&result, 4);
        if (c >= '0' && c <= '9') {
          result += (c - '0');
        }
        else
#line 1512
        if (c >= 'a' && c <= 'f') {
          result += (c - 'a' + 10);
        }
        else
#line 1514
        if (c >= 'A' && c <= 'F') {
          result += (c - 'A' + 10);
        }
        else {
          
#line 1517
          @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$", @"\\u", [NSString java_stringWithCharacters:self->buffer_ offset:self->pos_ length:4]));
        }
      }
      self->pos_ += 4;
      return result;
      
#line 1523
      case 't':
      return 0x0009;
      
#line 1526
      case 'b':
      return 0x0008;
      
#line 1529
      case 'n':
      return 0x000a;
      
#line 1532
      case 'r':
      return 0x000d;
      
#line 1535
      case 'f':
      return 0x000c;
      
#line 1538
      case 0x000a:
      self->lineNumber_++;
      self->lineStart_ = self->pos_;
      
#line 1543
      case '\'':
      case '"':
      case '\\':
      case '/':
      return escaped;
      default:
      
#line 1550
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Invalid escape sequence"));
    }
  }
}


#line 1558
JavaIoIOException *GsonJsonReader_syntaxErrorWithNSString_(GsonJsonReader *self, NSString *message) {
  @throw new_GsonMalformedJsonException_initWithNSString_(JreStrcat("$$", message, GsonJsonReader_locationString(self)));
}


#line 1565
void GsonJsonReader_consumeNonExecutePrefix(GsonJsonReader *self) {
  
#line 1567
  GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
  self->pos_--;
  
#line 1570
  if (self->pos_ + ((IOSCharArray *) nil_chk(GsonJsonReader_NON_EXECUTE_PREFIX))->size_ > self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, GsonJsonReader_NON_EXECUTE_PREFIX->size_)) {
    return;
  }
  
#line 1574
  for (jint i = 0; i < GsonJsonReader_NON_EXECUTE_PREFIX->size_; i++) {
    if (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i) != IOSCharArray_Get(GsonJsonReader_NON_EXECUTE_PREFIX, i)) {
      return;
    }
  }
  
#line 1581
  self->pos_ += GsonJsonReader_NON_EXECUTE_PREFIX->size_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GsonJsonReader)

J2OBJC_NAME_MAPPING(GsonJsonReader, "com.google.gson.stream", "Gson")

#line 1 "/Users/ahmedmohammed/intelliJWorkspace/employee-gson/src/main/java/com/google/gson/stream/JsonReader.java"


#line 1585
@implementation GsonJsonReader_1

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 1585
- (instancetype)init {
  GsonJsonReader_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 1586
- (void)promoteNameToValueWithGsonJsonReader:(GsonJsonReader *)reader {
  if ([reader isKindOfClass:[GsonJsonTreeReader class]]) {
    [((GsonJsonTreeReader *) nil_chk(((GsonJsonTreeReader *) cast_chk(reader, [GsonJsonTreeReader class])))) promoteNameToValue];
    return;
  }
  jint p = ((GsonJsonReader *) nil_chk(reader))->peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [reader doPeek];
  }
  if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
    reader->peeked_ = GsonJsonReader_PEEKED_DOUBLE_QUOTED;
  }
  else
#line 1597
  if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
    reader->peeked_ = GsonJsonReader_PEEKED_SINGLE_QUOTED;
  }
  else
#line 1599
  if (p == GsonJsonReader_PEEKED_UNQUOTED_NAME) {
    reader->peeked_ = GsonJsonReader_PEEKED_UNQUOTED;
  }
  else {
    
#line 1602
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a name but was ",
#line 1603
    [reader peek], GsonJsonReader_locationString(reader)));
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(promoteNameToValueWithGsonJsonReader:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "promoteNameToValue", "LGsonJsonReader;", "LJavaIoIOException;" };
  static const J2ObjcClassInfo _GsonJsonReader_1 = { "", "com.google.gson.stream", ptrTable, methods, NULL, 7, 0x8018, 2, 0, 1, -1, -1, -1, -1 };
  return &_GsonJsonReader_1;
}

@end


#line 1585
void GsonJsonReader_1_init(GsonJsonReader_1 *self) {
  GsonJsonReaderInternalAccess_init(self);
}


#line 1585
GsonJsonReader_1 *new_GsonJsonReader_1_init() {
  J2OBJC_NEW_IMPL(GsonJsonReader_1, init)
}


#line 1585
GsonJsonReader_1 *create_GsonJsonReader_1_init() {
  J2OBJC_CREATE_IMPL(GsonJsonReader_1, init)
}
